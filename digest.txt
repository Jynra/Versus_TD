Directory structure:
└── Versus_TD/
    ├── README.md
    ├── Makefile
    ├── quick_fixes.sh
    ├── temp_stubs.c
    ├── includes/
    │   ├── config.h
    │   ├── entities.h
    │   ├── game.h
    │   ├── systems.h
    │   ├── types.h
    │   └── utils.h
    ├── objs/
    │   ├── entities/
    │   ├── game/
    │   ├── systems/
    │   └── utils/
    └── srcs/
        ├── main.c
        ├── entities/
        ├── game/
        │   ├── cleanup.c
        │   ├── init.c
        │   ├── render.c
        │   └── update.c
        ├── systems/
        │   └── input.c
        └── utils/
            ├── debug.c
            ├── file.c
            ├── math.c
            └── memory.c

================================================
File: README.md
================================================
# Versus TD Clean - Phase 2 Complete

## 🎯 État Actuel

**Phase 2 terminée** : Fondations et utilitaires implémentés avec succès !

### ✅ Ce qui fonctionne actuellement

- **Architecture propre** respectant la norme Jynra
- **Système de build professionnel** avec Makefile avancé
- **Initialisation SDL** complète (fenêtre, renderer, fonts)
- **Système de debug** avec logs colorés et niveaux
- **Utilitaires mathématiques** (vecteurs, couleurs, distances)
- **Gestion mémoire** sécurisée avec tracking
- **Boucle de jeu** de base (update/render)
- **Système d'input** (clavier/souris)
- **Rendu primitif** (lignes, cercles, rectangles, texte)

### 🎮 Fonctionnalités Actuelles

Lancez `./versus_td_clean` pour tester :

- **Fenêtre de jeu** 1024x768 avec titre
- **Debug info** (F1) : FPS, statistiques
- **Grille de jeu** visible en mode debug
- **Chemin des ennemis** tracé en jaune
- **Pause/Resume** (ESC)
- **Interface basique** avec boutons de tours

## 🏗️ Architecture Implémentée

```
Versus_TD_Clean/
├── includes/           # Headers complets (6 fichiers)
│   ├── config.h       # 200+ constantes
│   ├── types.h        # Toutes les structures
│   ├── game.h         # Interface principale
│   ├── entities.h     # Entités du jeu
│   ├── systems.h      # Systèmes
│   └── utils.h        # Utilitaires
├── srcs/
│   ├── main.c         # Point d'entrée ✅
│   ├── game/          # Logique principale ✅
│   │   ├── init.c     # Initialisation SDL
│   │   ├── update.c   # Boucle de jeu
│   │   ├── render.c   # Système de rendu
│   │   └── cleanup.c  # Nettoyage
│   ├── utils/         # Utilitaires ✅
│   │   ├── math.c     # Maths + vecteurs
│   │   ├── debug.c    # Système de debug
│   │   ├── memory.c   # Gestion mémoire
│   │   └── file.c     # Opérations fichiers
│   └── systems/       # Systèmes de base ✅
│       └── input.c    # Gestion entrées
└── Makefile           # Build system complet ✅
```

## 🚀 Quick Start

```bash
# Compiler et tester
chmod +x test_build.sh
./test_build.sh

# Ou manuellement
make clean
make
./versus_td_clean

# Commandes utiles
make debug          # Build debug
make stats          # Statistiques projet
make help           # Aide complète
```

## 🎯 Prochaine Phase : Entités de Base

### Phase 3 - Entités (Semaine prochaine)

**Objectif** : Premier gameplay fonctionnel

1. **Tours de base** (`srcs/entities/tower.c`)
   - Placement sur grille
   - Rotation vers cibles
   - Tir de projectiles
   - 4 types : Basic, Sniper, Cannon, Freeze

2. **Ennemis de base** (`srcs/entities/enemy.c`)
   - Mouvement le long du chemin
   - Points de vie + barre de santé
   - 4 types : Basic, Fast, Tank, Flying

3. **Projectiles** (`srcs/entities/projectile.c`)
   - Trajectoire vers cible
   - Collision et dégâts
   - Effets visuels simples

4. **Système de spawn** (`srcs/entities/spawner.c`)
   - Apparition automatique d'ennemis
   - Vagues basiques

**Résultat attendu** : Jeu fonctionnel où on peut placer des tours qui tirent sur des ennemis !

## 📊 Statistiques Actuelles

- **Fichiers sources** : 10
- **Fichiers headers** : 6
- **Lignes de code** : ~1,500
- **Fonctions** : ~80 (toutes < 25 lignes)
- **Structures** : 15+ définies
- **Constantes** : 100+ configurables

## 🔧 Outils de Développement

### Commandes Make Disponibles

```bash
make                # Build normal
make debug          # Build avec debug symbols
make release        # Build optimisé
make clean          # Nettoyer objets
make fclean         # Nettoyer tout
make re             # Rebuild complet
make run            # Compiler et lancer
make test           # Test rapide
make stats          # Statistiques
make help           # Aide complète
```

### Debug et Tests

- **Logs colorés** : ERROR (rouge), WARN (jaune), INFO (vert)
- **Validation automatique** : Pointeurs, ranges, strings
- **FPS counter** : Affiché en mode debug
- **Memory tracking** : Allocations surveillées

## 🎮 Contrôles Actuels

| Touche | Action |
|--------|--------|
| F1 | Toggle debug info |
| R | Toggle range display |
| ESC | Pause/Resume |
| Clic | Interaction (préparé) |

## 📈 Roadmap

### ✅ Phase 1 - Fondations (Terminée)
- Structure et headers
- Build system

### ✅ Phase 2 - Utilitaires (Terminée)
- Maths, debug, mémoire
- SDL et rendu de base

### 🔄 Phase 3 - Entités (En cours)
- Tours, ennemis, projectiles
- Premier gameplay

### ⏳ Phase 4 - Systèmes Avancés
- Vagues, effets, UI
- Polish et équilibrage

## 💡 Notes de Développement

### Respect de la Norme Jynra
- ✅ Toutes les fonctions < 25 lignes
- ✅ Largeur < 80 colonnes
- ✅ Indentation 4 tabulations
- ✅ Nommage cohérent
- ✅ Pas de variables globales

### Qualité du Code
- **Modularité** : Chaque système indépendant
- **Lisibilité** : Code auto-documenté
- **Robustesse** : Validation partout
- **Performance** : Structures optimisées

### Architecture Extensible
- Ajout de nouveaux types d'entités facile
- Systèmes découplés
- Configuration centralisée
- Debug intégré

---

**Prêt pour la Phase 3 !** 🚀

L'architecture est solide, les fondations sont posées. Il est temps d'ajouter le gameplay !


================================================
File: Makefile
================================================
# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/05/25 16:00:00 by jynra             #+#    #+#              #
#    Updated: 2025/05/25 13:31:28 by ellucas          ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

# Program name
NAME = versus_td_clean

# Compiler and flags
CC = gcc
CFLAGS = -Wall -Wextra -Werror -std=c99
INCLUDES = -Iincludes
LIBS = -lSDL2 -lSDL2_ttf -lm

# Debug flags
DEBUG_FLAGS = -g3 -fsanitize=address -fsanitize=undefined -DDEBUG
RELEASE_FLAGS = -O3 -DNDEBUG

# Platform detection
UNAME_S := $(shell uname -s)
ifeq ($(UNAME_S),Darwin)
    INCLUDES += -I/usr/local/include -I/opt/homebrew/include
    LIBS += -L/usr/local/lib -L/opt/homebrew/lib
endif

# Directories
SRC_DIR = srcs
INC_DIR = includes
OBJ_DIR = objs

# =============================================================================
# PROGRESSIVE BUILD - ONLY IMPLEMENTED FILES
# =============================================================================

# Phase 2 - Current Implementation (Foundation + Utils)
PHASE2_SRCS = srcs/main.c \
              srcs/game/init.c \
              srcs/game/update.c \
              srcs/game/render.c \
              srcs/game/cleanup.c \
              srcs/utils/math.c \
              srcs/utils/debug.c \
              srcs/utils/memory.c \
              srcs/utils/file.c \
              srcs/systems/input.c \
              srcs/temp_stubs.c

# Phase 3 - Entities (To be implemented)
PHASE3_SRCS = srcs/entities/enemy.c \
              srcs/entities/tower.c \
              srcs/entities/projectile.c \
              srcs/entities/spawner.c

# Phase 4 - Advanced Systems (To be implemented)
PHASE4_SRCS = srcs/systems/physics.c \
              srcs/systems/effects.c \
              srcs/systems/waves.c \
              srcs/systems/ui.c \
              srcs/systems/upgrades.c

# =============================================================================
# CURRENT BUILD CONFIGURATION
# =============================================================================

# Use only Phase 2 files for now
SRCS = $(PHASE2_SRCS)

# Phase 3 build (when entities are ready)
SRCS_PHASE3 = $(PHASE2_SRCS) $(PHASE3_SRCS)

# Complete build (all phases)
SRCS_COMPLETE = $(PHASE2_SRCS) $(PHASE3_SRCS) $(PHASE4_SRCS)

# Object files
OBJS = $(SRCS:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)

# Header files for dependency tracking
HEADERS = includes/config.h \
         includes/types.h \
         includes/game.h \
         includes/entities.h \
         includes/systems.h \
         includes/utils.h

# Colors for pretty output
RED = \033[0;31m
GREEN = \033[0;32m
YELLOW = \033[0;33m
BLUE = \033[0;34m
PURPLE = \033[0;35m
CYAN = \033[0;36m
WHITE = \033[0;37m
RESET = \033[0m

# Progress tracking
TOTAL_FILES = $(words $(SRCS))
COMPILED_FILES = 0

# =============================================================================
# BUILD TARGETS
# =============================================================================

# Default target (Phase 2)
all: banner $(NAME)
	@echo "$(GREEN)✓ Phase 2 build completed successfully!$(RESET)"
	@echo "$(CYAN)Run with: ./$(NAME)$(RESET)"

# Phase 3 build (when ready)
phase3: SRCS = $(SRCS_PHASE3)
phase3: OBJS = $(SRCS:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)
phase3: banner $(NAME)
	@echo "$(GREEN)✓ Phase 3 build completed successfully!$(RESET)"

# Complete build (all phases)
complete: SRCS = $(SRCS_COMPLETE)
complete: OBJS = $(SRCS:$(SRC_DIR)/%.c=$(OBJ_DIR)/%.o)
complete: banner $(NAME)
	@echo "$(GREEN)✓ Complete build finished!$(RESET)"

# Create executable
$(NAME): $(OBJ_DIR) $(OBJS)
	@echo "$(YELLOW)Linking $(NAME)...$(RESET)"
	@$(CC) $(CFLAGS) $(OBJS) $(LIBS) -o $(NAME)
	@echo "$(GREEN)✓ Linking complete$(RESET)"

# Create object directory structure
$(OBJ_DIR):
	@echo "$(BLUE)Creating build directories...$(RESET)"
	@mkdir -p $(OBJ_DIR)
	@mkdir -p $(OBJ_DIR)/game
	@mkdir -p $(OBJ_DIR)/entities
	@mkdir -p $(OBJ_DIR)/systems
	@mkdir -p $(OBJ_DIR)/utils

# Compile source files
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c $(HEADERS)
	@$(eval COMPILED_FILES := $(shell echo $$(($(COMPILED_FILES) + 1))))
	@printf "$(YELLOW)[%2d/%2d]$(RESET) Compiling %-30s" $(COMPILED_FILES) $(TOTAL_FILES) "$<"
	@$(CC) $(CFLAGS) $(INCLUDES) -c $< -o $@
	@echo " $(GREEN)✓$(RESET)"

# =============================================================================
# DEVELOPMENT TARGETS
# =============================================================================

# Debug build
debug: CFLAGS += $(DEBUG_FLAGS)
debug: clean banner $(NAME)
	@echo "$(RED)✓ Debug build complete$(RESET)"

# Release build
release: CFLAGS += $(RELEASE_FLAGS)
release: clean banner $(NAME)
	@echo "$(GREEN)✓ Release build complete$(RESET)"

# Test the current phase
test: $(NAME)
	@echo "$(BLUE)Testing current build...$(RESET)"
	@timeout 3s ./$(NAME) || echo "$(GREEN)✓ Build test passed$(RESET)"

# Show what files are included in current build
show-files:
	@echo "$(CYAN)Current build includes:$(RESET)"
	@for file in $(SRCS); do echo "  ✓ $$file"; done
	@echo ""
	@echo "$(YELLOW)Phase 3 will add:$(RESET)"
	@for file in $(PHASE3_SRCS); do echo "  ⏳ $$file"; done
	@echo ""
	@echo "$(BLUE)Phase 4 will add:$(RESET)"
	@for file in $(PHASE4_SRCS); do echo "  ⏳ $$file"; done

# Check what files are missing
check-missing:
	@echo "$(BLUE)Checking for missing source files...$(RESET)"
	@missing=0; \
	for file in $(SRCS); do \
		if [ ! -f "$$file" ]; then \
			echo "$(RED)❌ Missing: $$file$(RESET)"; \
			missing=$$((missing + 1)); \
		fi; \
	done; \
	if [ $$missing -eq 0 ]; then \
		echo "$(GREEN)✓ All required files present for current phase$(RESET)"; \
	else \
		echo "$(RED)❌ $$missing files missing$(RESET)"; \
	fi

# =============================================================================
# UTILITY TARGETS
# =============================================================================

# Clean object files
clean:
	@echo "$(RED)Cleaning build files...$(RESET)"
	@rm -rf $(OBJ_DIR)
	@echo "$(GREEN)✓ Clean complete$(RESET)"

# Full clean
fclean: clean
	@echo "$(RED)Removing executable...$(RESET)"
	@rm -f $(NAME)
	@echo "$(GREEN)✓ Full clean complete$(RESET)"

# Rebuild
re: fclean all

# Run the game
run: $(NAME)
	@echo "$(CYAN)Starting $(NAME)...$(RESET)"
	@./$(NAME)

# Count lines of code (current files only)
count:
	@echo "$(BLUE)Counting lines of code (current phase)...$(RESET)"
	@echo "$(CYAN)Source files:$(RESET)"
	@wc -l $(SRCS) 2>/dev/null | tail -1 || echo "Some files missing"
	@echo "$(CYAN)Header files:$(RESET)"
	@find $(INC_DIR) -name "*.h" | xargs wc -l | tail -1

# Show project statistics
stats:
	@echo "$(CYAN)=== Versus TD Clean - Project Statistics ===$(RESET)"
	@echo "$(WHITE)Current Phase:$(RESET) 2 (Foundation + Utils)"
	@echo "$(WHITE)Implemented files:$(RESET) $(words $(SRCS))"
	@echo "$(WHITE)Phase 3 files:$(RESET) $(words $(PHASE3_SRCS))"
	@echo "$(WHITE)Phase 4 files:$(RESET) $(words $(PHASE4_SRCS))"
	@echo "$(WHITE)Total planned:$(RESET) $(words $(SRCS_COMPLETE))"
	@echo "$(WHITE)Headers:$(RESET) $(words $(HEADERS))"
	@echo "$(WHITE)Progress:$(RESET) $(shell echo "scale=1; $(words $(SRCS)) * 100 / $(words $(SRCS_COMPLETE))" | bc)%"

# Show help
help:
	@echo "$(CYAN)Versus TD Clean - Progressive Makefile Help$(RESET)"
	@echo ""
	@echo "$(WHITE)Build Targets:$(RESET)"
	@echo "  $(GREEN)all$(RESET)              - Build current phase (Phase 2)"
	@echo "  $(GREEN)phase3$(RESET)           - Build with Phase 3 files (when ready)"
	@echo "  $(GREEN)complete$(RESET)         - Build complete project (when ready)"
	@echo "  $(GREEN)debug$(RESET)            - Build with debug symbols"
	@echo "  $(GREEN)release$(RESET)          - Build optimized version"
	@echo "  $(GREEN)clean$(RESET)            - Remove object files"
	@echo "  $(GREEN)fclean$(RESET)           - Remove all generated files"
	@echo "  $(GREEN)re$(RESET)               - Rebuild everything"
	@echo ""
	@echo "$(WHITE)Development:$(RESET)"
	@echo "  $(YELLOW)run$(RESET)              - Build and run the game"
	@echo "  $(YELLOW)test$(RESET)             - Quick build verification"
	@echo "  $(YELLOW)show-files$(RESET)       - Show current and planned files"
	@echo "  $(YELLOW)check-missing$(RESET)    - Check for missing files"
	@echo ""
	@echo "$(WHITE)Information:$(RESET)"
	@echo "  $(BLUE)count$(RESET)            - Count lines of code"
	@echo "  $(BLUE)stats$(RESET)            - Show project statistics"
	@echo "  $(BLUE)help$(RESET)             - Show this help"

# Project banner
banner:
	@echo "$(CYAN)"
	@echo "╔══════════════════════════════════════════════════════════════╗"
	@echo "║                 VERSUS TD CLEAN - PHASE 2                    ║"
	@echo "║              Foundation + Utilities Ready                    ║"
	@echo "║                                                              ║"
	@echo "║  Current: $(words $(SRCS)) files | Next: Phase 3 Entities             ║"
	@echo "╚══════════════════════════════════════════════════════════════╝"
	@echo "$(RESET)"

# Phony targets
.PHONY: all phase3 complete clean fclean re debug release run test \
        show-files check-missing count stats help banner

# Disable built-in rules
.SUFFIXES:

# Default goal
.DEFAULT_GOAL := all


================================================
File: quick_fixes.sh
================================================
#!/bin/bash

# Script de corrections rapides pour la compilation

echo "🔧 Application des corrections rapides..."

# 1. Corriger les includes manquants dans debug.c
cat > srcs/utils/debug_fixed.c << 'EOF'
#include "utils.h"
#include <stdarg.h>
#include <time.h>

static void	debug_print_time(void);
static void	debug_print_level(const char *level, const char *color);

void	debug_log(const char *format, ...)
{
	va_list	args;

	debug_print_time();
	debug_print_level("LOG", "\033[0;37m");
	va_start(args, format);
	vprintf(format, args);
	va_end(args);
	printf("\033[0m\n");
	fflush(stdout);
}

void	debug_error(const char *format, ...)
{
	va_list	args;

	debug_print_time();
	debug_print_level("ERROR", "\033[0;31m");
	va_start(args, format);
	vprintf(format, args);
	va_end(args);
	printf("\033[0m\n");
	fflush(stderr);
}

void	debug_warning(const char *format, ...)
{
	va_list	args;

	debug_print_time();
	debug_print_level("WARN", "\033[0;33m");
	va_start(args, format);
	vprintf(format, args);
	va_end(args);
	printf("\033[0m\n");
	fflush(stdout);
}

void	debug_info(const char *format, ...)
{
	va_list	args;

	debug_print_time();
	debug_print_level("INFO", "\033[0;32m");
	va_start(args, format);
	vprintf(format, args);
	va_end(args);
	printf("\033[0m\n");
	fflush(stdout);
}

void	debug_print_vector2(const char *name, t_vector2 vec)
{
	debug_info("%s: (%.2f, %.2f)", name, vec.x, vec.y);
}

void	debug_print_rect(const char *name, t_rect rect)
{
	debug_info("%s: (%d, %d, %d, %d)", name, rect.x, rect.y, rect.w, rect.h);
}

void	debug_print_color(const char *name, t_color color)
{
	debug_info("%s: (%d, %d, %d, %d)", name, color.r, color.g, color.b, 
		color.a);
}

static void	debug_print_time(void)
{
	time_t		raw_time;
	struct tm	*time_info;
	char		time_str[20];

	time(&raw_time);
	time_info = localtime(&raw_time);
	strftime(time_str, sizeof(time_str), "%H:%M:%S", time_info);
	printf("[%s] ", time_str);
}

static void	debug_print_level(const char *level, const char *color)
{
	printf("%s[%-5s]\033[0m ", color, level);
}

float	time_get_delta(void)
{
	static Uint32	last_time = 0;
	Uint32			current_time;
	float			delta;

	current_time = SDL_GetTicks();
	if (last_time == 0)
		last_time = current_time;
	delta = (current_time - last_time) / 1000.0f;
	last_time = current_time;
	return (delta);
}

Uint32	time_get_ticks(void)
{
	return (SDL_GetTicks());
}

void	time_delay(Uint32 ms)
{
	SDL_Delay(ms);
}

float	time_get_fps(void)
{
	static Uint32	last_time = 0;
	static int		frame_count = 0;
	static float	fps = 0.0f;
	Uint32			current_time;

	frame_count++;
	current_time = SDL_GetTicks();
	if (current_time - last_time >= 1000)
	{
		fps = frame_count * 1000.0f / (current_time - last_time);
		frame_count = 0;
		last_time = current_time;
	}
	return (fps);
}

bool	validate_pointer(const void *ptr)
{
	if (!ptr)
	{
		printf("ERROR: Null pointer detected\n");
		return (false);
	}
	return (true);
}

bool	validate_range_int(int value, int min, int max)
{
	if (value < min || value > max)
	{
		printf("WARN: Value %d out of range [%d, %d]\n", value, min, max);
		return (false);
	}
	return (true);
}

bool	validate_range_float(float value, float min, float max)
{
	if (value < min || value > max)
	{
		printf("WARN: Value %.2f out of range [%.2f, %.2f]\n", value, min, max);
		return (false);
	}
	return (true);
}

bool	validate_string(const char *str)
{
	if (!str)
	{
		printf("ERROR: Null string detected\n");
		return (false);
	}
	if (string_length(str) == 0)
	{
		printf("WARN: Empty string detected\n");
		return (false);
	}
	return (true);
}
EOF

# 2. Créer un systems/basic_systems.c minimal qui compile
mkdir -p srcs/systems
cat > srcs/systems/basic_systems.c << 'EOF'
#include "systems.h"

void	input_init(t_input *input)
{
	int	i;

	if (!input)
		return ;
	input->mouse_pos = vec2_zero();
	input->mouse_world_pos = vec2_zero();
	input->mouse_left_down = false;
	input->mouse_right_down = false;
	input->mouse_left_clicked = false;
	input->mouse_right_clicked = false;
	i = 0;
	while (i < SDL_NUM_SCANCODES)
	{
		input->keys[i] = false;
		input->keys_pressed[i] = false;
		i++;
	}
}

void	input_update(t_input *input)
{
	int	i;

	if (!input)
		return ;
	input->mouse_left_clicked = false;
	input->mouse_right_clicked = false;
	i = 0;
	while (i < SDL_NUM_SCANCODES)
	{
		input->keys_pressed[i] = false;
		i++;
	}
}

void	input_handle_event(t_input *input, SDL_Event *event)
{
	if (!input || !event)
		return ;
	if (event->type == SDL_MOUSEBUTTONDOWN)
	{
		if (event->button.button == SDL_BUTTON_LEFT)
		{
			input->mouse_left_down = true;
			input->mouse_left_clicked = true;
		}
		else if (event->button.button == SDL_BUTTON_RIGHT)
		{
			input->mouse_right_down = true;
			input->mouse_right_clicked = true;
		}
	}
	else if (event->type == SDL_MOUSEBUTTONUP)
	{
		if (event->button.button == SDL_BUTTON_LEFT)
			input->mouse_left_down = false;
		else if (event->button.button == SDL_BUTTON_RIGHT)
			input->mouse_right_down = false;
	}
	else if (event->type == SDL_MOUSEMOTION)
	{
		input->mouse_pos.x = (float)event->motion.x;
		input->mouse_pos.y = (float)event->motion.y;
		input->mouse_world_pos = input->mouse_pos;
	}
	else if (event->type == SDL_KEYDOWN && !event->key.repeat)
	{
		input->keys[event->key.keysym.scancode] = true;
		input->keys_pressed[event->key.keysym.scancode] = true;
	}
	else if (event->type == SDL_KEYUP)
		input->keys[event->key.keysym.scancode] = false;
}

void	effects_init(t_game *game)
{
	int	i;

	if (!game)
		return ;
	i = 0;
	while (i < MAX_PARTICLES)
	{
		game->particles[i].active = false;
		i++;
	}
}

void	waves_init(t_wave *wave)
{
	int	i;

	if (!wave)
		return ;
	wave->number = 1;
	wave->enemies_total = WAVE_BASE_ENEMIES;
	wave->enemies_spawned = 0;
	wave->enemies_alive = 0;
	wave->spawn_delay = WAVE_SPAWN_DELAY_BASE;
	wave->spawn_timer = 0.0f;
	wave->prep_timer = 0.0f;
	wave->active = false;
	wave->completed = false;
	wave->preparing = true;
	wave->current_spawn_type = 0;
	i = 0;
	while (i < 4)
	{
		wave->enemy_types[i] = ENEMY_BASIC;
		wave->enemy_counts[i] = 0;
		i++;
	}
	wave->enemy_types[0] = ENEMY_BASIC;
	wave->enemy_counts[0] = wave->enemies_total;
}

void	notifications_init(t_game *game)
{
	int	i;

	if (!game)
		return ;
	i = 0;
	while (i < MAX_NOTIFICATIONS)
	{
		game->notifications[i].active = false;
		i++;
	}
}

void	ui_init(t_game *game)
{
	int	i;

	if (!game)
		return ;
	i = 0;
	while (i < 4)
	{
		game->tower_buttons[i].rect = rect_create(
			10 + i * (UI_BUTTON_WIDTH + UI_BUTTON_PADDING),
			GAME_AREA_HEIGHT + UI_BUTTON_PADDING,
			UI_BUTTON_WIDTH,
			UI_BUTTON_HEIGHT
		);
		game->tower_buttons[i].type = i + 1;
		game->tower_buttons[i].enabled = true;
		game->tower_buttons[i].pressed = false;
		game->tower_buttons[i].hovered = false;
		game->tower_buttons[i].color = color_gray();
		i++;
	}
	string_copy(game->tower_buttons[0].text, "Basic");
	string_copy(game->tower_buttons[1].text, "Sniper");
	string_copy(game->tower_buttons[2].text, "Cannon");
	string_copy(game->tower_buttons[3].text, "Freeze");
}
EOF

echo "✅ Corrections appliquées"
echo "📝 Remplacez maintenant:"
echo "   mv srcs/utils/debug_fixed.c srcs/utils/debug.c"
echo "   Ajoutez srcs/systems/basic_systems.c au Makefile"


================================================
File: temp_stubs.c
================================================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   temp_stubs.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/25 16:00:00 by jynra             #+#    #+#             */
/*   Updated: 2025/05/25 13:34:04 by ellucas          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "game.h"

/* Temporary stub implementations for functions not yet implemented */

/* Entity functions - Phase 3 */
void	entities_update_all(t_game *game)
{
	(void)game;
	/* TODO: Implement entity updates in Phase 3 */
}

void	entities_render_all(t_game *game)
{
	(void)game;
	/* TODO: Implement entity rendering in Phase 3 */
}

int	entities_count_active_towers(t_game *game)
{
	int	count;
	int	i;

	if (!validate_pointer(game))
		return (0);
	count = 0;
	i = 0;
	while (i < MAX_TOWERS)
	{
		if (game->towers[i].base.active)
			count++;
		i++;
	}
	return (count);
}

int	entities_count_active_enemies(t_game *game)
{
	int	count;
	int	i;

	if (!validate_pointer(game))
		return (0);
	count = 0;
	i = 0;
	while (i < MAX_ENEMIES)
	{
		if (game->enemies[i].base.active)
			count++;
		i++;
	}
	return (count);
}

/* Wave system functions */
void	waves_update(t_wave *wave, t_game *game)
{
	(void)wave;
	(void)game;
	/* TODO: Implement wave logic in Phase 3 */
}

/* Effects system functions */
void	effects_update(t_game *game)
{
	(void)game;
	/* TODO: Implement effects updates in Phase 3 */
}

void	effects_render(t_game *game)
{
	(void)game;
	/* TODO: Implement effects rendering in Phase 3 */
}

/* Notification system functions */
void	notifications_update(t_game *game)
{
	(void)game;
	/* TODO: Implement notifications updates in Phase 3 */
}

void	notifications_render(t_game *game)
{
	(void)game;
	/* TODO: Implement notifications rendering in Phase 3 */
}

/* UI system functions */
void	ui_update(t_game *game)
{
	(void)game;
	/* TODO: Implement UI updates in Phase 3 */
}

void	ui_render(t_game *game)
{
	int		i;
	t_color	button_color;
	t_color	text_color;
	t_vector2	text_pos;

	if (!validate_pointer(game))
		return ;
	/* Simple tower button rendering */
	i = 0;
	while (i < 4)
	{
		button_color = game->tower_buttons[i].enabled ? 
			color_create(100, 100, 150, 255) : color_create(50, 50, 50, 255);
		text_color = color_white();
		render_rect(game, game->tower_buttons[i].rect, button_color);
		text_pos.x = game->tower_buttons[i].rect.x + 5;
		text_pos.y = game->tower_buttons[i].rect.y + 5;
		if (game->font_small)
			render_text(game, game->tower_buttons[i].text, text_pos, 
				text_color, game->font_small);
		i++;
	}
}


================================================
File: includes/config.h
================================================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   config.h                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/25 16:00:00 by jynra             #+#    #+#             */
/*   Updated: 2025/05/25 12:28:03 by ellucas          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CONFIG_H
# define CONFIG_H

/* Window and Display Settings */
# define WINDOW_WIDTH 1024
# define WINDOW_HEIGHT 768
# define WINDOW_TITLE "Versus TD - Clean Edition"
# define FPS 60
# define FRAME_DELAY (1000 / FPS)

/* Game Area Layout */
# define TOOLBAR_HEIGHT 80
# define GAME_AREA_WIDTH WINDOW_WIDTH
# define GAME_AREA_HEIGHT (WINDOW_HEIGHT - TOOLBAR_HEIGHT)

/* Grid System */
# define GRID_SIZE 32
# define GRID_COLS (GAME_AREA_WIDTH / GRID_SIZE)
# define GRID_ROWS (GAME_AREA_HEIGHT / GRID_SIZE)

/* Entity Limits */
# define MAX_TOWERS 50
# define MAX_ENEMIES 100
# define MAX_PROJECTILES 200
# define MAX_PARTICLES 300
# define MAX_NOTIFICATIONS 8
# define MAX_PATH_POINTS 20

/* Game States */
# define STATE_MENU 0
# define STATE_PLAYING 1
# define STATE_PAUSED 2
# define STATE_GAME_OVER 3
# define STATE_VICTORY 4

/* Entity Types */
# define ENTITY_NONE 0
# define ENTITY_TOWER 1
# define ENTITY_ENEMY 2
# define ENTITY_PROJECTILE 3

/* Tower Types */
# define TOWER_BASIC 1
# define TOWER_SNIPER 2
# define TOWER_CANNON 3
# define TOWER_FREEZE 4

/* Tower Stats - Basic */
# define TOWER_BASIC_DAMAGE 25
# define TOWER_BASIC_RANGE 80.0f
# define TOWER_BASIC_FIRE_RATE 1.5f
# define TOWER_BASIC_COST 20

/* Tower Stats - Sniper */
# define TOWER_SNIPER_DAMAGE 80
# define TOWER_SNIPER_RANGE 150.0f
# define TOWER_SNIPER_FIRE_RATE 0.8f
# define TOWER_SNIPER_COST 50

/* Tower Stats - Cannon */
# define TOWER_CANNON_DAMAGE 60
# define TOWER_CANNON_RANGE 100.0f
# define TOWER_CANNON_FIRE_RATE 0.6f
# define TOWER_CANNON_COST 80

/* Tower Stats - Freeze */
# define TOWER_FREEZE_DAMAGE 15
# define TOWER_FREEZE_RANGE 90.0f
# define TOWER_FREEZE_FIRE_RATE 1.2f
# define TOWER_FREEZE_COST 40
# define TOWER_FREEZE_DURATION 3.0f
# define TOWER_FREEZE_SLOW_FACTOR 0.3f

/* Enemy Types */
# define ENEMY_BASIC 1
# define ENEMY_FAST 2
# define ENEMY_TANK 3
# define ENEMY_FLYING 4

/* Enemy Stats - Basic */
# define ENEMY_BASIC_HEALTH 100
# define ENEMY_BASIC_SPEED 30.0f
# define ENEMY_BASIC_REWARD 10
# define ENEMY_BASIC_SCORE 50

/* Enemy Stats - Fast */
# define ENEMY_FAST_HEALTH 60
# define ENEMY_FAST_SPEED 60.0f
# define ENEMY_FAST_REWARD 15
# define ENEMY_FAST_SCORE 75

/* Enemy Stats - Tank */
# define ENEMY_TANK_HEALTH 300
# define ENEMY_TANK_SPEED 15.0f
# define ENEMY_TANK_REWARD 30
# define ENEMY_TANK_SCORE 150

/* Enemy Stats - Flying */
# define ENEMY_FLYING_HEALTH 80
# define ENEMY_FLYING_SPEED 45.0f
# define ENEMY_FLYING_REWARD 20
# define ENEMY_FLYING_SCORE 100

/* Projectile Stats */
# define PROJECTILE_SPEED 200.0f
# define PROJECTILE_SIZE 4
# define PROJECTILE_LIFETIME 5.0f

/* Particle Types */
# define PARTICLE_EXPLOSION 1
# define PARTICLE_SMOKE 2
# define PARTICLE_SPARK 3
# define PARTICLE_BLOOD 4

/* Particle Settings */
# define PARTICLE_LIFETIME_MIN 0.5f
# define PARTICLE_LIFETIME_MAX 2.0f
# define PARTICLE_SPEED_MIN 20.0f
# define PARTICLE_SPEED_MAX 80.0f
# define PARTICLE_SIZE_MIN 2.0f
# define PARTICLE_SIZE_MAX 8.0f

/* Notification Types */
# define NOTIF_INFO 1
# define NOTIF_SUCCESS 2
# define NOTIF_WARNING 3
# define NOTIF_ERROR 4
# define NOTIF_DURATION 3.0f

/* Wave System */
# define MAX_WAVES 30
# define WAVE_PREP_TIME 5.0f
# define WAVE_BASE_ENEMIES 8
# define WAVE_ENEMY_INCREMENT 3
# define WAVE_SPAWN_DELAY_BASE 1.5f
# define WAVE_SPAWN_DELAY_MIN 0.3f

/* Game Balance */
# define STARTING_MONEY 100
# define STARTING_LIVES 20
# define TOWER_UPGRADE_COST_MULTIPLIER 1.5f
# define TOWER_MAX_LEVEL 3

/* Colors (RGB) */
# define COLOR_WHITE_R 255
# define COLOR_WHITE_G 255
# define COLOR_WHITE_B 255

# define COLOR_BLACK_R 0
# define COLOR_BLACK_G 0
# define COLOR_BLACK_B 0

# define COLOR_RED_R 255
# define COLOR_RED_G 50
# define COLOR_RED_B 50

# define COLOR_GREEN_R 50
# define COLOR_GREEN_G 255
# define COLOR_GREEN_B 50

# define COLOR_BLUE_R 50
# define COLOR_BLUE_G 50
# define COLOR_BLUE_B 255

# define COLOR_YELLOW_R 255
# define COLOR_YELLOW_G 255
# define COLOR_YELLOW_B 50

# define COLOR_GRAY_R 128
# define COLOR_GRAY_G 128
# define COLOR_GRAY_B 128

# define COLOR_DARK_GRAY_R 64
# define COLOR_DARK_GRAY_G 64
# define COLOR_DARK_GRAY_B 64

/* UI Layout */
# define UI_BUTTON_WIDTH 60
# define UI_BUTTON_HEIGHT 60
# define UI_BUTTON_PADDING 10
# define UI_TEXT_PADDING 5

/* Terrain Types */
# define TERRAIN_GRASS 0
# define TERRAIN_PATH 1
# define TERRAIN_BLOCKED 2

/* Input Settings */
# define MOUSE_BUTTON_LEFT 1
# define MOUSE_BUTTON_RIGHT 3

/* Debug Settings */
# define DEBUG_SHOW_RANGES 1
# define DEBUG_SHOW_PATHS 1
# define DEBUG_SHOW_GRID 0
# define DEBUG_SHOW_FPS 1

/* File Paths */
# define FONT_PATH "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf"
# define FONT_SIZE_SMALL 12
# define FONT_SIZE_MEDIUM 16
# define FONT_SIZE_LARGE 24

/* Math Constants */
# define PI 3.14159265359f
# define TWO_PI 6.28318530718f
# define HALF_PI 1.57079632679f

/* Utility Macros */
# define MIN(a, b) ((a) < (b) ? (a) : (b))
# define MAX(a, b) ((a) > (b) ? (a) : (b))
# define CLAMP(x, min, max) (MIN(MAX(x, min), max))
# define ABS(x) ((x) < 0 ? -(x) : (x))

#endif


================================================
File: includes/entities.h
================================================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   entities.h                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/25 16:00:00 by jynra             #+#    #+#             */
/*   Updated: 2025/05/25 12:29:02 by ellucas          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef ENTITIES_H
# define ENTITIES_H

# include "types.h"

/* Base Entity Functions */
void	entity_init(t_entity *entity);
void	entity_update(t_entity *entity, t_game *game);
bool	entity_is_alive(t_entity *entity);
float	entity_distance(t_entity *a, t_entity *b);
bool	entity_collision(t_entity *a, t_entity *b);
void	entity_take_damage(t_entity *entity, int damage);
void	entity_heal(t_entity *entity, int amount);

/* Tower Functions */
void	tower_init(t_tower *tower);
void	tower_create(t_tower *tower, t_vector2 pos, int type);
void	tower_update(t_tower *tower, t_game *game);
void	tower_render(t_tower *tower, t_game *game);
void	tower_fire(t_tower *tower, t_game *game);
void	tower_upgrade(t_tower *tower);
bool	tower_can_upgrade(t_tower *tower, t_game *game);
int		tower_get_upgrade_cost(t_tower *tower);
void	tower_set_stats(t_tower *tower, int type);
t_enemy	*tower_find_target(t_tower *tower, t_game *game);
bool	tower_in_range(t_tower *tower, t_enemy *enemy);
void	tower_destroy(t_tower *tower);

/* Enemy Functions */
void	enemy_init(t_enemy *enemy);
void	enemy_create(t_enemy *enemy, int type);
void	enemy_update(t_enemy *enemy, t_game *game);
void	enemy_render(t_enemy *enemy, t_game *game);
void	enemy_move(t_enemy *enemy, t_game *game);
void	enemy_take_damage(t_enemy *enemy, int damage, t_game *game);
void	enemy_apply_slow(t_enemy *enemy, float duration, float factor);
void	enemy_set_stats(t_enemy *enemy, int type);
bool	enemy_reached_end(t_enemy *enemy, t_game *game);
void	enemy_destroy(t_enemy *enemy, t_game *game);
t_vector2	enemy_get_next_waypoint(t_enemy *enemy, t_game *game);

/* Projectile Functions */
void	projectile_init(t_projectile *projectile);
void	projectile_create(t_projectile *proj, t_vector2 pos, t_vector2 target,
			int damage);
void	projectile_update(t_projectile *projectile, t_game *game);
void	projectile_render(t_projectile *projectile, t_game *game);
bool	projectile_hit_target(t_projectile *projectile, t_enemy *enemy);
void	projectile_explode(t_projectile *projectile, t_game *game);
void	projectile_destroy(t_projectile *projectile);

/* Entity Management Functions */
int		entities_find_free_tower(t_game *game);
int		entities_find_free_enemy(t_game *game);
int		entities_find_free_projectile(t_game *game);
void	entities_update_all(t_game *game);
void	entities_render_all(t_game *game);
void	entities_cleanup_inactive(t_game *game);
int		entities_count_active_enemies(t_game *game);
int		entities_count_active_towers(t_game *game);

/* Entity Spawning Functions */
bool	spawn_tower(t_game *game, t_vector2 pos, int type);
bool	spawn_enemy(t_game *game, int type);
bool	spawn_projectile(t_game *game, t_vector2 pos, t_vector2 target,
			int damage);

/* Entity Selection and Interaction */
t_tower	*get_tower_at_position(t_game *game, t_vector2 pos);
t_enemy	*get_nearest_enemy(t_game *game, t_vector2 pos, float max_range);
void	select_tower(t_game *game, int tower_id);
void	deselect_all_towers(t_game *game);

#endif


================================================
File: includes/game.h
================================================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   game.h                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/25 16:00:00 by jynra             #+#    #+#             */
/*   Updated: 2025/05/25 12:36:40 by ellucas          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef GAME_H
# define GAME_H

# include "types.h"
# include "entities.h"
# include "systems.h"
# include "utils.h"

/* Core Game Functions */
bool	game_init(t_game *game);
void	game_run(t_game *game);
void	game_cleanup(t_game *game);
void	game_shutdown(t_game *game);

/* Game Loop Functions */
void	game_update(t_game *game);
void	game_render(t_game *game);
void	game_handle_events(t_game *game);

/* Game State Management */
void	game_set_state(t_game *game, int state);
int		game_get_state(t_game *game);
bool	game_is_paused(t_game *game);
void	game_toggle_pause(t_game *game);

/* Game Resources Management */
void	game_add_money(t_game *game, int amount);
bool	game_spend_money(t_game *game, int amount);
void	game_lose_life(t_game *game);
void	game_add_score(t_game *game, int points);

/* Game Utility Functions */
float	game_get_delta_time(t_game *game);
void	game_update_delta_time(t_game *game);
bool	game_is_running(t_game *game);

/* Game World Functions */
void	game_init_world(t_game *game);
void	game_init_path(t_game *game);
void	game_init_grid(t_game *game);
bool	game_is_position_valid(t_game *game, t_vector2 pos);

/* Game Statistics */
void	game_update_stats(t_game *game);
void	game_reset_stats(t_game *game);

#endif


================================================
File: includes/systems.h
================================================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   systems.h                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/25 16:00:00 by jynra             #+#    #+#             */
/*   Updated: 2025/05/25 12:29:17 by ellucas          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef SYSTEMS_H
# define SYSTEMS_H

# include "types.h"

/* Input System */
void	input_init(t_input *input);
void	input_update(t_input *input);
void	input_handle_event(t_input *input, SDL_Event *event);
bool	input_is_key_pressed(t_input *input, int scancode);
bool	input_is_key_down(t_input *input, int scancode);
bool	input_mouse_clicked(t_input *input, int button);
bool	input_mouse_down(t_input *input, int button);
t_vector2	input_get_mouse_pos(t_input *input);
t_vector2	input_screen_to_world(t_input *input, t_vector2 screen_pos);

/* Physics System */
void	physics_update(t_game *game);
bool	physics_circle_collision(t_vector2 pos1, float r1, t_vector2 pos2,
			float r2);
bool	physics_point_in_circle(t_vector2 point, t_vector2 center, float radius);
bool	physics_point_in_rect(t_vector2 point, t_rect rect);
float	physics_distance(t_vector2 a, t_vector2 b);
t_vector2	physics_normalize(t_vector2 vec);
t_vector2	physics_rotate(t_vector2 vec, float angle);

/* Wave System */
void	waves_init(t_wave *wave);
void	waves_update(t_wave *wave, t_game *game);
void	waves_start_next(t_wave *wave, t_game *game);
void	waves_spawn_enemy(t_wave *wave, t_game *game);
bool	waves_is_complete(t_wave *wave, t_game *game);
bool	waves_all_enemies_dead(t_game *game);
void	waves_calculate_spawn_data(t_wave *wave);
int		waves_get_enemy_type_for_wave(int wave_number, int spawn_index);

/* Effects System */
void	effects_init(t_game *game);
void	effects_update(t_game *game);
void	effects_render(t_game *game);
void	effects_create_explosion(t_game *game, t_vector2 pos, int intensity);
void	effects_create_blood(t_game *game, t_vector2 pos);
void	effects_create_smoke(t_game *game, t_vector2 pos);
void	effects_create_sparks(t_game *game, t_vector2 pos, int count);
int		effects_find_free_particle(t_game *game);
void	effects_cleanup_particles(t_game *game);

/* UI System */
void	ui_init(t_game *game);
void	ui_update(t_game *game);
void	ui_render(t_game *game);
void	ui_render_hud(t_game *game);
void	ui_render_tower_buttons(t_game *game);
void	ui_render_tower_info(t_game *game);
void	ui_render_wave_info(t_game *game);
void	ui_handle_click(t_game *game, t_vector2 pos);
bool	ui_button_clicked(t_button *button, t_vector2 pos);
void	ui_button_update(t_button *button, t_vector2 mouse_pos);

/* Notification System */
void	notifications_init(t_game *game);
void	notifications_update(t_game *game);
void	notifications_render(t_game *game);
void	notifications_add(t_game *game, const char *text, int type);
int		notifications_find_free(t_game *game);
void	notifications_cleanup(t_game *game);

/* Upgrade System */
void	upgrades_init(t_game *game);
bool	upgrades_tower(t_game *game, int tower_id);
int		upgrades_get_cost(t_tower *tower);
void	upgrades_apply_stats(t_tower *tower);
bool	upgrades_can_afford(t_game *game, t_tower *tower);

/* Render System */
void	render_init(t_game *game);
void	render_clear(t_game *game);
void	render_present(t_game *game);
void	render_grid(t_game *game);
void	render_path(t_game *game);
void	render_ranges(t_game *game);
void	render_circle(t_game *game, t_vector2 center, float radius, t_color color);
void	render_rect(t_game *game, t_rect rect, t_color color);
void	render_line(t_game *game, t_vector2 start, t_vector2 end, t_color color);
void	render_text(t_game *game, const char *text, t_vector2 pos, t_color color,
			TTF_Font *font);

#endif


================================================
File: includes/types.h
================================================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   types.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/25 16:00:00 by jynra             #+#    #+#             */
/*   Updated: 2025/05/25 12:36:37 by ellucas          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef TYPES_H
# define TYPES_H

# include <SDL2/SDL.h>
# include <SDL2/SDL_ttf.h>
# include <stdbool.h>
# include "config.h"

/* Basic 2D Vector */
typedef struct s_vector2
{
	float	x;
	float	y;
}	t_vector2;

/* Integer Rectangle */
typedef struct s_rect
{
	int		x;
	int		y;
	int		w;
	int		h;
}	t_rect;

/* Color Structure */
typedef struct s_color
{
	int		r;
	int		g;
	int		b;
	int		a;
}	t_color;

/* Base Entity Structure */
typedef struct s_entity
{
	t_vector2	pos;
	t_vector2	vel;
	float		radius;
	int			health;
	int			max_health;
	int			type;
	bool		active;
	float		rotation;
}	t_entity;

/* Tower Structure */
typedef struct s_tower
{
	t_entity	base;
	float		range;
	int			damage;
	float		fire_rate;
	float		fire_timer;
	int			level;
	int			kills;
	int			cost;
	int			total_damage_dealt;
	bool		selected;
	int			upgrade_cost;
}	t_tower;

/* Enemy Structure */
typedef struct s_enemy
{
	t_entity	base;
	float		speed;
	float		base_speed;
	int			path_index;
	int			reward;
	int			score_value;
	bool		slowed;
	float		slow_timer;
	bool		flying;
	float		spawn_time;
}	t_enemy;

/* Projectile Structure */
typedef struct s_projectile
{
	t_entity	base;
	int			damage;
	int			target_id;
	float		lifetime;
	bool		piercing;
	bool		explosive;
	float		explosion_radius;
}	t_projectile;

/* Particle Structure */
typedef struct s_particle
{
	t_vector2	pos;
	t_vector2	vel;
	float		life;
	float		max_life;
	float		size;
	float		start_size;
	t_color		color;
	t_color		start_color;
	int			type;
	bool		active;
	float		gravity;
}	t_particle;

/* Notification Structure */
typedef struct s_notification
{
	char		text[256];
	float		timer;
	float		max_time;
	int			type;
	bool		active;
	float		alpha;
	t_vector2	pos;
}	t_notification;

/* Wave Structure */
typedef struct s_wave
{
	int			number;
	int			enemies_total;
	int			enemies_spawned;
	int			enemies_alive;
	float		spawn_delay;
	float		spawn_timer;
	float		prep_timer;
	bool		active;
	bool		completed;
	bool		preparing;
	int			enemy_types[4];
	int			enemy_counts[4];
	int			current_spawn_type;
}	t_wave;

/* Path Point Structure */
typedef struct s_path_point
{
	t_vector2	pos;
	t_vector2	direction;
}	t_path_point;

/* UI Button Structure */
typedef struct s_button
{
	t_rect		rect;
	char		text[32];
	int			type;
	bool		enabled;
	bool		pressed;
	bool		hovered;
	t_color		color;
}	t_button;

/* Game Statistics */
typedef struct s_stats
{
	int			total_enemies_killed;
	int			total_money_earned;
	int			total_damage_dealt;
	int			towers_built;
	int			waves_completed;
	float		play_time;
	int			highest_wave;
	int			best_score;
}	t_stats;

/* Game Input State */
typedef struct s_input
{
	t_vector2	mouse_pos;
	t_vector2	mouse_world_pos;
	bool		mouse_left_down;
	bool		mouse_right_down;
	bool		mouse_left_clicked;
	bool		mouse_right_clicked;
	bool		keys[SDL_NUM_SCANCODES];
	bool		keys_pressed[SDL_NUM_SCANCODES];
}	t_input;

/* Grid Cell Structure */
typedef struct s_grid_cell
{
	int			type;
	bool		occupied;
	int			tower_id;
	float		movement_cost;
}	t_grid_cell;

/* Main Game Structure */
typedef struct s_game
{
	/* SDL Components */
	SDL_Window		*window;
	SDL_Renderer	*renderer;
	TTF_Font		*font_small;
	TTF_Font		*font_medium;
	TTF_Font		*font_large;

	/* Game State */
	bool			running;
	bool			paused;
	int				state;
	float			delta_time;
	Uint32			last_frame_time;

	/* Game Resources */
	int				money;
	int				lives;
	int				score;
	int				multiplier;

	/* Entities Arrays */
	t_tower			towers[MAX_TOWERS];
	t_enemy			enemies[MAX_ENEMIES];
	t_projectile	projectiles[MAX_PROJECTILES];
	t_particle		particles[MAX_PARTICLES];
	t_notification	notifications[MAX_NOTIFICATIONS];

	/* Game Systems */
	t_wave			current_wave;
	t_input			input;
	t_stats			stats;

	/* World Data */
	t_grid_cell		grid[GRID_ROWS][GRID_COLS];
	t_path_point	path[MAX_PATH_POINTS];
	int				path_length;

	/* UI State */
	int				selected_tower_type;
	bool			placing_tower;
	int				selected_tower_id;
	t_button		tower_buttons[4];
	t_button		ui_buttons[8];
	bool			show_ranges;
	bool			show_debug;

	/* Performance Counters */
	int				active_towers;
	int				active_enemies;
	int				active_projectiles;
	int				active_particles;
	float			fps;
	int				frame_count;
	float			fps_timer;
}	t_game;

/* Function Pointer Types */
typedef void	(*t_update_func)(void *entity, t_game *game);
typedef void	(*t_render_func)(void *entity, t_game *game);
typedef void	(*t_cleanup_func)(void *entity);

/* Entity System Function Table */
typedef struct s_entity_funcs
{
	t_update_func	update;
	t_render_func	render;
	t_cleanup_func	cleanup;
}	t_entity_funcs;

#endif


================================================
File: includes/utils.h
================================================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/25 16:00:00 by jynra             #+#    #+#             */
/*   Updated: 2025/05/25 12:29:30 by ellucas          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef UTILS_H
# define UTILS_H

# include "types.h"
# include <stdio.h>
# include <stdlib.h>
# include <math.h>
# include <string.h>
# include <time.h>

/* Math Utilities */
float		math_distance(t_vector2 a, t_vector2 b);
float		math_distance_squared(t_vector2 a, t_vector2 b);
t_vector2	math_normalize(t_vector2 vec);
float		math_magnitude(t_vector2 vec);
float		math_magnitude_squared(t_vector2 vec);
t_vector2	math_rotate(t_vector2 vec, float angle);
float		math_angle_between(t_vector2 a, t_vector2 b);
float		math_lerp(float a, float b, float t);
float		math_clamp(float value, float min, float max);
int			math_clamp_int(int value, int min, int max);
float		math_deg_to_rad(float degrees);
float		math_rad_to_deg(float radians);

/* Vector Operations */
t_vector2	vec2_add(t_vector2 a, t_vector2 b);
t_vector2	vec2_subtract(t_vector2 a, t_vector2 b);
t_vector2	vec2_multiply(t_vector2 vec, float scalar);
t_vector2	vec2_divide(t_vector2 vec, float scalar);
t_vector2	vec2_zero(void);
t_vector2	vec2_one(void);
t_vector2	vec2_create(float x, float y);
bool		vec2_equals(t_vector2 a, t_vector2 b);

/* Color Utilities */
t_color		color_create(int r, int g, int b, int a);
t_color		color_white(void);
t_color		color_black(void);
t_color		color_red(void);
t_color		color_green(void);
t_color		color_blue(void);
t_color		color_yellow(void);
t_color		color_gray(void);
t_color		color_lerp(t_color a, t_color b, float t);
SDL_Color	color_to_sdl(t_color color);

/* Rectangle Utilities */
t_rect		rect_create(int x, int y, int w, int h);
bool		rect_contains_point(t_rect rect, t_vector2 point);
bool		rect_intersects(t_rect a, t_rect b);
t_rect		rect_intersection(t_rect a, t_rect b);
t_vector2	rect_center(t_rect rect);

/* Memory Management */
void		*memory_alloc(size_t size);
void		memory_free(void *ptr);
void		*memory_realloc(void *ptr, size_t size);
void		memory_set(void *ptr, int value, size_t size);
void		memory_copy(void *dest, const void *src, size_t size);
int			memory_compare(const void *a, const void *b, size_t size);

/* File Operations */
bool		file_exists(const char *filename);
char		*file_read_text(const char *filename);
bool		file_write_text(const char *filename, const char *content);
size_t		file_get_size(const char *filename);
bool		file_copy(const char *src, const char *dest);
bool		file_delete(const char *filename);

/* String Utilities */
int			string_length(const char *str);
char		*string_copy(char *dest, const char *src);
char		*string_concat(char *dest, const char *src);
int			string_compare(const char *a, const char *b);
char		*string_find(const char *haystack, const char *needle);
void		string_to_lower(char *str);
void		string_to_upper(char *str);
bool		string_starts_with(const char *str, const char *prefix);
bool		string_ends_with(const char *str, const char *suffix);

/* Random Number Generation */
void		random_seed(unsigned int seed);
int			random_int(int min, int max);
float		random_float(float min, float max);
bool		random_chance(float probability);
t_vector2	random_vector2(float min_x, float max_x, float min_y, float max_y);
t_color		random_color(void);

/* Debug Utilities */
void		debug_log(const char *format, ...);
void		debug_error(const char *format, ...);
void		debug_warning(const char *format, ...);
void		debug_info(const char *format, ...);
void		debug_print_vector2(const char *name, t_vector2 vec);
void		debug_print_rect(const char *name, t_rect rect);
void		debug_print_color(const char *name, t_color color);

/* Time Utilities */
float		time_get_delta(void);
Uint32		time_get_ticks(void);
void		time_delay(Uint32 ms);
float		time_get_fps(void);

/* Grid/World Conversion */
t_vector2	world_to_grid(t_vector2 world_pos);
t_vector2	grid_to_world(int grid_x, int grid_y);
bool		is_valid_grid_pos(int x, int y);
int			world_to_grid_x(float world_x);
int			world_to_grid_y(float world_y);
float		grid_to_world_x(int grid_x);
float		grid_to_world_y(int grid_y);

/* Pathfinding Utilities */
float		pathfind_heuristic(t_vector2 a, t_vector2 b);
bool		pathfind_is_walkable(t_game *game, int x, int y);
t_vector2	pathfind_get_direction(t_vector2 from, t_vector2 to);

/* Performance Utilities */
void		perf_start_timer(const char *name);
void		perf_end_timer(const char *name);
void		perf_print_stats(void);
void		perf_reset_stats(void);

/* Validation Utilities */
bool		validate_pointer(const void *ptr);
bool		validate_range_int(int value, int min, int max);
bool		validate_range_float(float value, float min, float max);
bool		validate_string(const char *str);

#endif






================================================
File: srcs/main.c
================================================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/25 16:00:00 by jynra             #+#    #+#             */
/*   Updated: 2025/05/25 12:45:39 by ellucas          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "game.h"

static void	print_banner(void);
static void	print_usage(void);
static int	handle_arguments(int argc, char **argv);

int	main(int argc, char **argv)
{
	t_game	game;
	int		arg_result;

	print_banner();
	arg_result = handle_arguments(argc, argv);
	if (arg_result != 0)
		return (arg_result);
	if (!game_init(&game))
	{
		debug_error("Failed to initialize game");
		return (1);
	}
	debug_info("Game initialized successfully");
	game_run(&game);
	game_cleanup(&game);
	debug_info("Game shutdown complete");
	return (0);
}

static void	print_banner(void)
{
	printf("\n");
	printf("╔══════════════════════════════════════════════════════════════╗\n");
	printf("║                    VERSUS TD CLEAN                           ║\n");
	printf("║                Tower Defense - Clean Edition                ║\n");
	printf("║                                                              ║\n");
	printf("║  Version: 1.0.0                                             ║\n");
	printf("║  Built: %s %s                               ║\n", __DATE__, __TIME__);
	printf("║  Architecture: Clean & Modular                              ║\n");
	printf("╚══════════════════════════════════════════════════════════════╝\n");
	printf("\n");
}

static void	print_usage(void)
{
	printf("Usage: %s [options]\n", "versus_td_clean");
	printf("\n");
	printf("Options:\n");
	printf("  -h, --help     Show this help message\n");
	printf("  -v, --version  Show version information\n");
	printf("  -d, --debug    Enable debug mode\n");
	printf("  --windowed     Force windowed mode\n");
	printf("  --fullscreen   Force fullscreen mode\n");
	printf("\n");
}

static int	handle_arguments(int argc, char **argv)
{
	int	i;

	if (argc == 1)
		return (0);
	i = 1;
	while (i < argc)
	{
		if (string_compare(argv[i], "-h") == 0 
			|| string_compare(argv[i], "--help") == 0)
		{
			print_usage();
			return (0);
		}
		else if (string_compare(argv[i], "-v") == 0 
			|| string_compare(argv[i], "--version") == 0)
		{
			printf("Versus TD Clean v1.0.0\n");
			return (0);
		}
		else if (string_compare(argv[i], "-d") == 0 
			|| string_compare(argv[i], "--debug") == 0)
		{
			debug_info("Debug mode enabled");
		}
		else
		{
			printf("Unknown option: %s\n", argv[i]);
			print_usage();
			return (1);
		}
		i++;
	}
	return (0);
}



================================================
File: srcs/game/cleanup.c
================================================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cleanup.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/25 16:00:00 by jynra             #+#    #+#             */
/*   Updated: 2025/05/25 13:07:25 by ellucas          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "game.h"

static void	cleanup_fonts(t_game *game);
static void	cleanup_renderer(t_game *game);
static void	cleanup_window(t_game *game);
static void	cleanup_sdl(void);

void	game_cleanup(t_game *game)
{
	if (!game)
	{
		debug_warning("Attempting to cleanup NULL game");
		return ;
	}
	debug_info("Starting game cleanup...");
	cleanup_fonts(game);
	cleanup_renderer(game);
	cleanup_window(game);
	cleanup_sdl();
	debug_info("Game cleanup complete");
}

void	game_shutdown(t_game *game)
{
	if (!game)
		return ;
	debug_info("Shutting down game...");
	game->running = false;
	game_cleanup(game);
}

static void	cleanup_fonts(t_game *game)
{
	debug_info("Cleaning up fonts...");
	if (game->font_small)
	{
		TTF_CloseFont(game->font_small);
		game->font_small = NULL;
	}
	if (game->font_medium)
	{
		TTF_CloseFont(game->font_medium);
		game->font_medium = NULL;
	}
	if (game->font_large)
	{
		TTF_CloseFont(game->font_large);
		game->font_large = NULL;
	}
	debug_info("Fonts cleaned up");
}

static void	cleanup_renderer(t_game *game)
{
	debug_info("Cleaning up renderer...");
	if (game->renderer)
	{
		SDL_DestroyRenderer(game->renderer);
		game->renderer = NULL;
	}
	debug_info("Renderer cleaned up");
}

static void	cleanup_window(t_game *game)
{
	debug_info("Cleaning up window...");
	if (game->window)
	{
		SDL_DestroyWindow(game->window);
		game->window = NULL;
	}
	debug_info("Window cleaned up");
}

static void	cleanup_sdl(void)
{
	debug_info("Shutting down SDL...");
	TTF_Quit();
	SDL_Quit();
	debug_info("SDL shutdown complete");
}


================================================
File: srcs/game/init.c
================================================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/25 16:00:00 by jynra             #+#    #+#             */
/*   Updated: 2025/05/25 13:21:09 by ellucas          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "game.h"

static bool	init_sdl(void);
static bool	init_window(t_game *game);
static bool	init_renderer(t_game *game);
static bool	init_fonts(t_game *game);
static bool	init_game_data(t_game *game);

bool	game_init(t_game *game)
{
	if (!validate_pointer(game))
		return (false);
	debug_info("Initializing game...");
	memory_set(game, 0, sizeof(t_game));
	if (!init_sdl())
		return (false);
	if (!init_window(game))
		return (false);
	if (!init_renderer(game))
		return (false);
	if (!init_fonts(game))
		return (false);
	if (!init_game_data(game))
		return (false);
	debug_info("Game initialization complete");
	return (true);
}

static bool	init_sdl(void)
{
	debug_info("Initializing SDL...");
	if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) < 0)
	{
		debug_error("SDL initialization failed: %s", SDL_GetError());
		return (false);
	}
	if (TTF_Init() == -1)
	{
		debug_error("SDL_ttf initialization failed: %s", TTF_GetError());
		SDL_Quit();
		return (false);
	}
	debug_info("SDL initialized successfully");
	return (true);
}

static bool	init_window(t_game *game)
{
	debug_info("Creating window (%dx%d)...", WINDOW_WIDTH, WINDOW_HEIGHT);
	game->window = SDL_CreateWindow(
		WINDOW_TITLE,
		SDL_WINDOWPOS_CENTERED,
		SDL_WINDOWPOS_CENTERED,
		WINDOW_WIDTH,
		WINDOW_HEIGHT,
		SDL_WINDOW_SHOWN | SDL_WINDOW_RESIZABLE
	);
	if (!game->window)
	{
		debug_error("Window creation failed: %s", SDL_GetError());
		return (false);
	}
	debug_info("Window created successfully");
	return (true);
}

static bool	init_renderer(t_game *game)
{
	debug_info("Creating renderer...");
	game->renderer = SDL_CreateRenderer(
		game->window,
		-1,
		SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC
	);
	if (!game->renderer)
	{
		debug_error("Renderer creation failed: %s", SDL_GetError());
		return (false);
	}
	SDL_SetRenderDrawBlendMode(game->renderer, SDL_BLENDMODE_BLEND);
	debug_info("Renderer created successfully");
	return (true);
}

static bool	init_fonts(t_game *game)
{
	debug_info("Loading fonts...");
	game->font_small = TTF_OpenFont(FONT_PATH, FONT_SIZE_SMALL);
	if (!game->font_small)
	{
		debug_warning("Small font loading failed: %s", TTF_GetError());
		debug_info("Using default system font");
	}
	game->font_medium = TTF_OpenFont(FONT_PATH, FONT_SIZE_MEDIUM);
	if (!game->font_medium)
	{
		debug_warning("Medium font loading failed: %s", TTF_GetError());
	}
	game->font_large = TTF_OpenFont(FONT_PATH, FONT_SIZE_LARGE);
	if (!game->font_large)
	{
		debug_warning("Large font loading failed: %s", TTF_GetError());
	}
	debug_info("Font loading complete");
	return (true);
}

static bool	init_game_data(t_game *game)
{
	debug_info("Initializing game data...");
	game->running = true;
	game->paused = false;
	game->state = STATE_MENU;
	game->money = STARTING_MONEY;
	game->lives = STARTING_LIVES;
	game->score = 0;
	game->multiplier = 1;
	game->selected_tower_type = TOWER_BASIC;
	game->placing_tower = false;
	game->selected_tower_id = -1;
	game->show_ranges = false;
	game->show_debug = false;
	game->last_frame_time = SDL_GetTicks();
	game->delta_time = 0.0f;
	game->fps = 0.0f;
	game->frame_count = 0;
	game->fps_timer = 0.0f;
	game_init_world(game);
	input_init(&game->input);
	effects_init(game);
	waves_init(&game->current_wave);
	notifications_init(game);
	ui_init(game);
	random_seed((unsigned int)time(NULL));
	debug_info("Game data initialized");
	return (true);
}

void	game_init_world(t_game *game)
{
	debug_info("Initializing game world...");
	game_init_grid(game);
	game_init_path(game);
	debug_info("Game world initialized");
}

void	game_init_grid(t_game *game)
{
	int	x;
	int	y;

	debug_info("Initializing grid (%dx%d)...", GRID_COLS, GRID_ROWS);
	y = 0;
	while (y < GRID_ROWS)
	{
		x = 0;
		while (x < GRID_COLS)
		{
			game->grid[y][x].type = TERRAIN_GRASS;
			game->grid[y][x].occupied = false;
			game->grid[y][x].tower_id = -1;
			game->grid[y][x].movement_cost = 1.0f;
			x++;
		}
		y++;
	}
}

void	game_init_path(t_game *game)
{
	int			path_y;
	int			x;
	t_vector2	start;
	t_vector2	end;

	debug_info("Initializing enemy path...");
	path_y = GRID_ROWS / 2;
	start = vec2_create(-GRID_SIZE, grid_to_world_y(path_y));
	end = vec2_create(WINDOW_WIDTH + GRID_SIZE, grid_to_world_y(path_y));
	game->path[0].pos = start;
	game->path[0].direction = vec2_create(1.0f, 0.0f);
	game->path[1].pos = end;
	game->path[1].direction = vec2_create(1.0f, 0.0f);
	game->path_length = 2;
	x = 0;
	while (x < GRID_COLS)
	{
		game->grid[path_y][x].type = TERRAIN_PATH;
		game->grid[path_y][x].movement_cost = 0.5f;
		x++;
	}
	debug_info("Path initialized: %d points", game->path_length);
}

bool	game_is_position_valid(t_game *game, t_vector2 pos)
{
	int	grid_x;
	int	grid_y;

	grid_x = world_to_grid_x(pos.x);
	grid_y = world_to_grid_y(pos.y);
	if (!is_valid_grid_pos(grid_x, grid_y))
		return (false);
	return (game->grid[grid_y][grid_x].type != TERRAIN_PATH
		&& !game->grid[grid_y][grid_x].occupied);
}


================================================
File: srcs/game/render.c
================================================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   render.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/25 16:00:00 by jynra             #+#    #+#             */
/*   Updated: 2025/05/25 13:33:39 by ellucas          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "game.h"

void	render_clear(t_game *game)
{
	t_color	bg_color;

	if (!validate_pointer(game))
		return ;
	bg_color = color_create(32, 48, 32, 255);
	SDL_SetRenderDrawColor(game->renderer, bg_color.r, bg_color.g, 
		bg_color.b, bg_color.a);
	SDL_RenderClear(game->renderer);
}

void	render_present(t_game *game)
{
	if (!validate_pointer(game))
		return ;
	SDL_RenderPresent(game->renderer);
}

void	render_grid(t_game *game)
{
	int		x;
	int		y;
	t_color	path_color;
	t_rect	cell_rect;

	if (!validate_pointer(game) || !game->show_debug)
		return ;
	path_color = color_create(139, 69, 19, 255);
	y = 0;
	while (y < GRID_ROWS)
	{
		x = 0;
		while (x < GRID_COLS)
		{
			cell_rect = rect_create(x * GRID_SIZE, y * GRID_SIZE, 
				GRID_SIZE, GRID_SIZE);
			if (game->grid[y][x].type == TERRAIN_PATH)
				render_rect(game, cell_rect, path_color);
			else if (game->grid[y][x].occupied)
				render_rect(game, cell_rect, color_create(128, 128, 128, 128));
			x++;
		}
		y++;
	}
}

void	render_path(t_game *game)
{
	int			i;
	t_vector2	start;
	t_vector2	end;
	t_color		path_color;

	if (!validate_pointer(game) || game->path_length < 2)
		return ;
	path_color = color_create(255, 255, 0, 128);
	i = 0;
	while (i < game->path_length - 1)
	{
		start = game->path[i].pos;
		end = game->path[i + 1].pos;
		render_line(game, start, end, path_color);
		i++;
	}
}

void	render_ranges(t_game *game)
{
	int		i;
	t_color	range_color;

	if (!validate_pointer(game))
		return ;
	range_color = color_create(255, 255, 255, 64);
	i = 0;
	while (i < MAX_TOWERS)
	{
		if (game->towers[i].base.active)
		{
			render_circle(game, game->towers[i].base.pos, 
				game->towers[i].range, range_color);
		}
		i++;
	}
}

void	render_circle(t_game *game, t_vector2 center, float radius, t_color color)
{
	int		segments;
	int		i;
	float	angle;
	float	next_angle;
	t_vector2	point1;
	t_vector2	point2;

	if (!validate_pointer(game) || radius <= 0)
		return ;
	segments = (int)(radius * 0.5f);
	if (segments < 8)
		segments = 8;
	if (segments > 64)
		segments = 64;
	SDL_SetRenderDrawColor(game->renderer, color.r, color.g, color.b, color.a);
	i = 0;
	while (i < segments)
	{
		angle = (2.0f * PI * i) / segments;
		next_angle = (2.0f * PI * (i + 1)) / segments;
		point1.x = center.x + cosf(angle) * radius;
		point1.y = center.y + sinf(angle) * radius;
		point2.x = center.x + cosf(next_angle) * radius;
		point2.y = center.y + sinf(next_angle) * radius;
		SDL_RenderDrawLineF(game->renderer, point1.x, point1.y, 
			point2.x, point2.y);
		i++;
	}
}

void	render_rect(t_game *game, t_rect rect, t_color color)
{
	SDL_Rect	sdl_rect;

	if (!validate_pointer(game))
		return ;
	sdl_rect.x = rect.x;
	sdl_rect.y = rect.y;
	sdl_rect.w = rect.w;
	sdl_rect.h = rect.h;
	SDL_SetRenderDrawColor(game->renderer, color.r, color.g, color.b, color.a);
	SDL_RenderFillRect(game->renderer, &sdl_rect);
}

void	render_line(t_game *game, t_vector2 start, t_vector2 end, t_color color)
{
	if (!validate_pointer(game))
		return ;
	SDL_SetRenderDrawColor(game->renderer, color.r, color.g, color.b, color.a);
	SDL_RenderDrawLineF(game->renderer, start.x, start.y, end.x, end.y);
}

void	render_text(t_game *game, const char *text, t_vector2 pos, t_color color,
		TTF_Font *font)
{
	SDL_Surface	*surface;
	SDL_Texture	*texture;
	SDL_Color	sdl_color;
	SDL_Rect	dest_rect;
	int			text_w;
	int			text_h;

	if (!validate_pointer(game) || !validate_string(text) || !font)
		return ;
	sdl_color = color_to_sdl(color);
	surface = TTF_RenderText_Blended(font, text, sdl_color);
	if (!surface)
		return ;
	texture = SDL_CreateTextureFromSurface(game->renderer, surface);
	if (!texture)
	{
		SDL_FreeSurface(surface);
		return ;
	}
	TTF_SizeText(font, text, &text_w, &text_h);
	dest_rect.x = (int)pos.x;
	dest_rect.y = (int)pos.y;
	dest_rect.w = text_w;
	dest_rect.h = text_h;
	SDL_RenderCopy(game->renderer, texture, NULL, &dest_rect);
	SDL_DestroyTexture(texture);
	SDL_FreeSurface(surface);
}

void	render_debug_info(t_game *game)
{
	char		fps_text[64];
	char		entities_text[128];
	char		game_info[128];
	t_vector2	text_pos;
	t_color		debug_color;

	if (!validate_pointer(game))
		return ;
	debug_color = color_white();
	sprintf(fps_text, "FPS: %.1f", game->fps);
	sprintf(entities_text, "Towers: %d | Enemies: %d | Projectiles: %d",
		game->active_towers, game->active_enemies, game->active_projectiles);
	sprintf(game_info, "Money: %d | Lives: %d | Score: %d | Wave: %d",
		game->money, game->lives, game->score, game->current_wave.number);
	text_pos = vec2_create(10, 10);
	render_text(game, fps_text, text_pos, debug_color, game->font_small);
	text_pos.y += 20;
	render_text(game, entities_text, text_pos, debug_color, game->font_small);
	text_pos.y += 20;
	render_text(game, game_info, text_pos, debug_color, game->font_small);
}


================================================
File: srcs/game/update.c
================================================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   update.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/25 16:00:00 by jynra             #+#    #+#             */
/*   Updated: 2025/05/25 13:28:45 by ellucas          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "game.h"

/* Forward declarations for functions implemented in render.c */
void	render_debug_info(t_game *game);

void	game_run(t_game *game)
{
	if (!validate_pointer(game))
		return ;
	debug_info("Starting game loop...");
	game->state = STATE_PLAYING;
	while (game->running)
	{
		game_update_delta_time(game);
		game_handle_events(game);
		if (!game->paused)
			game_update(game);
		game_render(game);
		SDL_Delay(1);
	}
	debug_info("Game loop ended");
}

void	game_handle_events(t_game *game)
{
	SDL_Event	event;

	input_update(&game->input);
	while (SDL_PollEvent(&event))
	{
		if (event.type == SDL_QUIT)
		{
			game->running = false;
			break ;
		}
		input_handle_event(&game->input, &event);
		if (event.type == SDL_KEYDOWN)
		{
			if (event.key.keysym.sym == SDLK_ESCAPE)
				game_toggle_pause(game);
			else if (event.key.keysym.sym == SDLK_F1)
				game->show_debug = !game->show_debug;
			else if (event.key.keysym.sym == SDLK_r)
				game->show_ranges = !game->show_ranges;
		}
	}
}

void	game_update(t_game *game)
{
	if (!validate_pointer(game))
		return ;
	game_update_stats(game);
	if (game->state == STATE_PLAYING)
	{
		waves_update(&game->current_wave, game);
		entities_update_all(game);
		effects_update(game);
		notifications_update(game);
		ui_update(game);
	}
}

void	game_render(t_game *game)
{
	if (!validate_pointer(game))
		return ;
	render_clear(game);
	if (game->state == STATE_PLAYING)
	{
		render_grid(game);
		render_path(game);
		entities_render_all(game);
		if (game->show_ranges)
			render_ranges(game);
		effects_render(game);
		ui_render(game);
		notifications_render(game);
		if (game->show_debug)
			render_debug_info(game);
	}
	render_present(game);
}

void	game_update_delta_time(t_game *game)
{
	Uint32	current_time;

	current_time = SDL_GetTicks();
	game->delta_time = (current_time - game->last_frame_time) / 1000.0f;
	game->last_frame_time = current_time;
	game->fps_timer += game->delta_time;
	game->frame_count++;
	if (game->fps_timer >= 1.0f)
	{
		game->fps = game->frame_count / game->fps_timer;
		game->frame_count = 0;
		game->fps_timer = 0.0f;
	}
}

void	game_update_stats(t_game *game)
{
	game->stats.play_time += game->delta_time;
	game->active_towers = entities_count_active_towers(game);
	game->active_enemies = entities_count_active_enemies(game);
}

float	game_get_delta_time(t_game *game)
{
	if (!validate_pointer(game))
		return (0.0f);
	return (game->delta_time);
}

bool	game_is_running(t_game *game)
{
	if (!validate_pointer(game))
		return (false);
	return (game->running);
}

void	game_set_state(t_game *game, int state)
{
	if (!validate_pointer(game))
		return ;
	if (state != game->state)
	{
		debug_info("Game state changed: %d -> %d", game->state, state);
		game->state = state;
	}
}

int	game_get_state(t_game *game)
{
	if (!validate_pointer(game))
		return (STATE_MENU);
	return (game->state);
}

bool	game_is_paused(t_game *game)
{
	if (!validate_pointer(game))
		return (true);
	return (game->paused);
}

void	game_toggle_pause(t_game *game)
{
	if (!validate_pointer(game))
		return ;
	game->paused = !game->paused;
	debug_info("Game %s", game->paused ? "paused" : "resumed");
}

void	game_add_money(t_game *game, int amount)
{
	if (!validate_pointer(game) || amount < 0)
		return ;
	game->money += amount;
	game->stats.total_money_earned += amount;
}

bool	game_spend_money(t_game *game, int amount)
{
	if (!validate_pointer(game) || amount < 0)
		return (false);
	if (game->money < amount)
		return (false);
	game->money -= amount;
	return (true);
}

void	game_lose_life(t_game *game)
{
	if (!validate_pointer(game))
		return ;
	game->lives--;
	if (game->lives <= 0)
	{
		debug_info("Game Over! Final score: %d", game->score);
		game_set_state(game, STATE_GAME_OVER);
	}
}

void	game_add_score(t_game *game, int points)
{
	if (!validate_pointer(game) || points < 0)
		return ;
	game->score += points * game->multiplier;
	if (game->score > game->stats.best_score)
		game->stats.best_score = game->score;
}


================================================
File: srcs/systems/input.c
================================================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   input.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/25 16:00:00 by jynra             #+#    #+#             */
/*   Updated: 2025/05/25 13:30:23 by ellucas          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "systems.h"

void	input_init(t_input *input)
{
	int	i;

	if (!validate_pointer(input))
		return ;
	input->mouse_pos = vec2_zero();
	input->mouse_world_pos = vec2_zero();
	input->mouse_left_down = false;
	input->mouse_right_down = false;
	input->mouse_left_clicked = false;
	input->mouse_right_clicked = false;
	i = 0;
	while (i < SDL_NUM_SCANCODES)
	{
		input->keys[i] = false;
		input->keys_pressed[i] = false;
		i++;
	}
	debug_info("Input system initialized");
}

void	input_update(t_input *input)
{
	int	i;

	if (!validate_pointer(input))
		return ;
	input->mouse_left_clicked = false;
	input->mouse_right_clicked = false;
	i = 0;
	while (i < SDL_NUM_SCANCODES)
	{
		input->keys_pressed[i] = false;
		i++;
	}
}

void	input_handle_event(t_input *input, SDL_Event *event)
{
	if (!validate_pointer(input) || !validate_pointer(event))
		return ;
	if (event->type == SDL_MOUSEBUTTONDOWN)
	{
		if (event->button.button == SDL_BUTTON_LEFT)
		{
			input->mouse_left_down = true;
			input->mouse_left_clicked = true;
		}
		else if (event->button.button == SDL_BUTTON_RIGHT)
		{
			input->mouse_right_down = true;
			input->mouse_right_clicked = true;
		}
	}
	else if (event->type == SDL_MOUSEBUTTONUP)
	{
		if (event->button.button == SDL_BUTTON_LEFT)
			input->mouse_left_down = false;
		else if (event->button.button == SDL_BUTTON_RIGHT)
			input->mouse_right_down = false;
	}
	else if (event->type == SDL_MOUSEMOTION)
	{
		input->mouse_pos.x = (float)event->motion.x;
		input->mouse_pos.y = (float)event->motion.y;
		input->mouse_world_pos = input->mouse_pos;
	}
	else if (event->type == SDL_KEYDOWN && !event->key.repeat)
	{
		input->keys[event->key.keysym.scancode] = true;
		input->keys_pressed[event->key.keysym.scancode] = true;
	}
	else if (event->type == SDL_KEYUP)
		input->keys[event->key.keysym.scancode] = false;
}

void	effects_init(t_game *game)
{
	int	i;

	if (!validate_pointer(game))
		return ;
	i = 0;
	while (i < MAX_PARTICLES)
	{
		game->particles[i].active = false;
		i++;
	}
	debug_info("Effects system initialized");
}

void	waves_init(t_wave *wave)
{
	int	i;

	if (!validate_pointer(wave))
		return ;
	wave->number = 1;
	wave->enemies_total = WAVE_BASE_ENEMIES;
	wave->enemies_spawned = 0;
	wave->enemies_alive = 0;
	wave->spawn_delay = WAVE_SPAWN_DELAY_BASE;
	wave->spawn_timer = 0.0f;
	wave->prep_timer = 0.0f;
	wave->active = false;
	wave->completed = false;
	wave->preparing = true;
	wave->current_spawn_type = 0;
	i = 0;
	while (i < 4)
	{
		wave->enemy_types[i] = ENEMY_BASIC;
		wave->enemy_counts[i] = 0;
		i++;
	}
	wave->enemy_types[0] = ENEMY_BASIC;
	wave->enemy_counts[0] = wave->enemies_total;
	debug_info("Wave system initialized");
}

void	notifications_init(t_game *game)
{
	int	i;

	if (!validate_pointer(game))
		return ;
	i = 0;
	while (i < MAX_NOTIFICATIONS)
	{
		game->notifications[i].active = false;
		i++;
	}
	debug_info("Notification system initialized");
}

void	ui_init(t_game *game)
{
	int	i;

	if (!validate_pointer(game))
		return ;
	i = 0;
	while (i < 4)
	{
		game->tower_buttons[i].rect = rect_create(
			10 + i * (UI_BUTTON_WIDTH + UI_BUTTON_PADDING),
			GAME_AREA_HEIGHT + UI_BUTTON_PADDING,
			UI_BUTTON_WIDTH,
			UI_BUTTON_HEIGHT
		);
		game->tower_buttons[i].type = i + 1;
		game->tower_buttons[i].enabled = true;
		game->tower_buttons[i].pressed = false;
		game->tower_buttons[i].hovered = false;
		game->tower_buttons[i].color = color_gray();
		i++;
	}
	string_copy(game->tower_buttons[0].text, "Basic");
	string_copy(game->tower_buttons[1].text, "Sniper");
	string_copy(game->tower_buttons[2].text, "Cannon");
	string_copy(game->tower_buttons[3].text, "Freeze");
	debug_info("UI system initialized");
}


================================================
File: srcs/utils/debug.c
================================================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   debug.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/25 16:00:00 by jynra             #+#    #+#             */
/*   Updated: 2025/05/25 13:25:18 by ellucas          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "utils.h"
#include <stdarg.h>
#include <time.h>

static void	debug_print_time(void);
static void	debug_print_level(const char *level, const char *color);

void	debug_log(const char *format, ...)
{
	va_list	args;

	debug_print_time();
	debug_print_level("LOG", "\033[0;37m");
	va_start(args, format);
	vprintf(format, args);
	va_end(args);
	printf("\033[0m\n");
	fflush(stdout);
}

void	debug_error(const char *format, ...)
{
	va_list	args;

	debug_print_time();
	debug_print_level("ERROR", "\033[0;31m");
	va_start(args, format);
	vprintf(format, args);
	va_end(args);
	printf("\033[0m\n");
	fflush(stderr);
}

void	debug_warning(const char *format, ...)
{
	va_list	args;

	debug_print_time();
	debug_print_level("WARN", "\033[0;33m");
	va_start(args, format);
	vprintf(format, args);
	va_end(args);
	printf("\033[0m\n");
	fflush(stdout);
}

void	debug_info(const char *format, ...)
{
	va_list	args;

	debug_print_time();
	debug_print_level("INFO", "\033[0;32m");
	va_start(args, format);
	vprintf(format, args);
	va_end(args);
	printf("\033[0m\n");
	fflush(stdout);
}

void	debug_print_vector2(const char *name, t_vector2 vec)
{
	debug_info("%s: (%.2f, %.2f)", name, vec.x, vec.y);
}

void	debug_print_rect(const char *name, t_rect rect)
{
	debug_info("%s: (%d, %d, %d, %d)", name, rect.x, rect.y, rect.w, rect.h);
}

void	debug_print_color(const char *name, t_color color)
{
	debug_info("%s: (%d, %d, %d, %d)", name, color.r, color.g, color.b, 
		color.a);
}

static void	debug_print_time(void)
{
	time_t		raw_time;
	struct tm	*time_info;
	char		time_str[20];

	time(&raw_time);
	time_info = localtime(&raw_time);
	strftime(time_str, sizeof(time_str), "%H:%M:%S", time_info);
	printf("[%s] ", time_str);
}

static void	debug_print_level(const char *level, const char *color)
{
	printf("%s[%-5s]\033[0m ", color, level);
}

float	time_get_delta(void)
{
	static Uint32	last_time = 0;
	Uint32			current_time;
	float			delta;

	current_time = SDL_GetTicks();
	if (last_time == 0)
		last_time = current_time;
	delta = (current_time - last_time) / 1000.0f;
	last_time = current_time;
	return (delta);
}

Uint32	time_get_ticks(void)
{
	return (SDL_GetTicks());
}

void	time_delay(Uint32 ms)
{
	SDL_Delay(ms);
}

float	time_get_fps(void)
{
	static Uint32	last_time = 0;
	static int		frame_count = 0;
	static float	fps = 0.0f;
	Uint32			current_time;

	frame_count++;
	current_time = SDL_GetTicks();
	if (current_time - last_time >= 1000)
	{
		fps = frame_count * 1000.0f / (current_time - last_time);
		frame_count = 0;
		last_time = current_time;
	}
	return (fps);
}

bool	validate_pointer(const void *ptr)
{
	if (!ptr)
	{
		printf("ERROR: Null pointer detected\n");
		return (false);
	}
	return (true);
}

bool	validate_range_int(int value, int min, int max)
{
	if (value < min || value > max)
	{
		printf("WARN: Value %d out of range [%d, %d]\n", value, min, max);
		return (false);
	}
	return (true);
}

bool	validate_range_float(float value, float min, float max)
{
	if (value < min || value > max)
	{
		printf("WARN: Value %.2f out of range [%.2f, %.2f]\n", value, min, max);
		return (false);
	}
	return (true);
}

bool	validate_string(const char *str)
{
	if (!str)
	{
		printf("ERROR: Null string detected\n");
		return (false);
	}
	if (string_length(str) == 0)
	{
		printf("WARN: Empty string detected\n");
		return (false);
	}
	return (true);
}



================================================
File: srcs/utils/file.c
================================================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   file.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/25 16:00:00 by jynra             #+#    #+#             */
/*   Updated: 2025/05/25 13:06:12 by ellucas          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "utils.h"
#include <sys/stat.h>
#include <unistd.h>

bool	file_exists(const char *filename)
{
	struct stat	buffer;

	if (!filename)
		return (false);
	return (stat(filename, &buffer) == 0);
}

char	*file_read_text(const char *filename)
{
	FILE	*file;
	char	*content;
	size_t	size;
	size_t	read_size;

	if (!filename || !file_exists(filename))
		return (NULL);
	file = fopen(filename, "r");
	if (!file)
	{
		debug_error("Failed to open file: %s", filename);
		return (NULL);
	}
	size = file_get_size(filename);
	content = memory_alloc(size + 1);
	if (!content)
	{
		fclose(file);
		return (NULL);
	}
	read_size = fread(content, 1, size, file);
	content[read_size] = '\0';
	fclose(file);
	debug_info("Read %zu bytes from file: %s", read_size, filename);
	return (content);
}

bool	file_write_text(const char *filename, const char *content)
{
	FILE	*file;
	size_t	content_len;
	size_t	written;

	if (!filename || !content)
		return (false);
	file = fopen(filename, "w");
	if (!file)
	{
		debug_error("Failed to create file: %s", filename);
		return (false);
	}
	content_len = string_length(content);
	written = fwrite(content, 1, content_len, file);
	fclose(file);
	if (written != content_len)
	{
		debug_error("Failed to write complete content to file: %s", filename);
		return (false);
	}
	debug_info("Wrote %zu bytes to file: %s", written, filename);
	return (true);
}

size_t	file_get_size(const char *filename)
{
	struct stat	buffer;

	if (!filename || stat(filename, &buffer) != 0)
		return (0);
	return (buffer.st_size);
}

bool	file_copy(const char *src, const char *dest)
{
	char	*content;
	bool	result;

	if (!src || !dest)
		return (false);
	if (!file_exists(src))
	{
		debug_error("Source file does not exist: %s", src);
		return (false);
	}
	content = file_read_text(src);
	if (!content)
		return (false);
	result = file_write_text(dest, content);
	memory_free(content);
	if (result)
		debug_info("File copied: %s -> %s", src, dest);
	return (result);
}

bool	file_delete(const char *filename)
{
	if (!filename)
		return (false);
	if (!file_exists(filename))
	{
		debug_warning("File does not exist: %s", filename);
		return (false);
	}
	if (unlink(filename) == 0)
	{
		debug_info("File deleted: %s", filename);
		return (true);
	}
	debug_error("Failed to delete file: %s", filename);
	return (false);
}

void	random_seed(unsigned int seed)
{
	srand(seed);
	debug_info("Random seed set to: %u", seed);
}

int	random_int(int min, int max)
{
	if (min >= max)
		return (min);
	return (min + rand() % (max - min + 1));
}

float	random_float(float min, float max)
{
	float	random_val;

	if (min >= max)
		return (min);
	random_val = (float)rand() / (float)RAND_MAX;
	return (min + random_val * (max - min));
}

bool	random_chance(float probability)
{
	if (probability <= 0.0f)
		return (false);
	if (probability >= 1.0f)
		return (true);
	return (random_float(0.0f, 1.0f) < probability);
}

t_vector2	random_vector2(float min_x, float max_x, float min_y, float max_y)
{
	t_vector2	result;

	result.x = random_float(min_x, max_x);
	result.y = random_float(min_y, max_y);
	return (result);
}

t_color	random_color(void)
{
	t_color	result;

	result.r = random_int(0, 255);
	result.g = random_int(0, 255);
	result.b = random_int(0, 255);
	result.a = 255;
	return (result);
}

t_rect	rect_create(int x, int y, int w, int h)
{
	t_rect	result;

	result.x = x;
	result.y = y;
	result.w = w;
	result.h = h;
	return (result);
}

bool	rect_contains_point(t_rect rect, t_vector2 point)
{
	return (point.x >= rect.x && point.x < rect.x + rect.w
		&& point.y >= rect.y && point.y < rect.y + rect.h);
}

bool	rect_intersects(t_rect a, t_rect b)
{
	return (a.x < b.x + b.w && a.x + a.w > b.x
		&& a.y < b.y + b.h && a.y + a.h > b.y);
}

t_rect	rect_intersection(t_rect a, t_rect b)
{
	t_rect	result;
	int		left;
	int		top;
	int		right;
	int		bottom;

	left = MAX(a.x, b.x);
	top = MAX(a.y, b.y);
	right = MIN(a.x + a.w, b.x + b.w);
	bottom = MIN(a.y + a.h, b.y + b.h);
	if (left < right && top < bottom)
	{
		result.x = left;
		result.y = top;
		result.w = right - left;
		result.h = bottom - top;
	}
	else
	{
		result.x = 0;
		result.y = 0;
		result.w = 0;
		result.h = 0;
	}
	return (result);
}

t_vector2	rect_center(t_rect rect)
{
	t_vector2	result;

	result.x = rect.x + rect.w * 0.5f;
	result.y = rect.y + rect.h * 0.5f;
	return (result);
}


================================================
File: srcs/utils/math.c
================================================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   math.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/25 16:00:00 by jynra             #+#    #+#             */
/*   Updated: 2025/05/25 13:02:00 by ellucas          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "utils.h"

float	math_distance(t_vector2 a, t_vector2 b)
{
	float	dx;
	float	dy;

	dx = b.x - a.x;
	dy = b.y - a.y;
	return (sqrtf(dx * dx + dy * dy));
}

float	math_distance_squared(t_vector2 a, t_vector2 b)
{
	float	dx;
	float	dy;

	dx = b.x - a.x;
	dy = b.y - a.y;
	return (dx * dx + dy * dy);
}

t_vector2	math_normalize(t_vector2 vec)
{
	float		magnitude;
	t_vector2	result;

	magnitude = math_magnitude(vec);
	if (magnitude == 0.0f)
		return (vec2_zero());
	result.x = vec.x / magnitude;
	result.y = vec.y / magnitude;
	return (result);
}

float	math_magnitude(t_vector2 vec)
{
	return (sqrtf(vec.x * vec.x + vec.y * vec.y));
}

float	math_magnitude_squared(t_vector2 vec)
{
	return (vec.x * vec.x + vec.y * vec.y);
}

t_vector2	math_rotate(t_vector2 vec, float angle)
{
	t_vector2	result;
	float		cos_a;
	float		sin_a;

	cos_a = cosf(angle);
	sin_a = sinf(angle);
	result.x = vec.x * cos_a - vec.y * sin_a;
	result.y = vec.x * sin_a + vec.y * cos_a;
	return (result);
}

float	math_angle_between(t_vector2 a, t_vector2 b)
{
	return (atan2f(b.y - a.y, b.x - a.x));
}

float	math_lerp(float a, float b, float t)
{
	return (a + (b - a) * t);
}

float	math_clamp(float value, float min, float max)
{
	if (value < min)
		return (min);
	if (value > max)
		return (max);
	return (value);
}

int	math_clamp_int(int value, int min, int max)
{
	if (value < min)
		return (min);
	if (value > max)
		return (max);
	return (value);
}

float	math_deg_to_rad(float degrees)
{
	return (degrees * PI / 180.0f);
}

float	math_rad_to_deg(float radians)
{
	return (radians * 180.0f / PI);
}

t_vector2	vec2_add(t_vector2 a, t_vector2 b)
{
	t_vector2	result;

	result.x = a.x + b.x;
	result.y = a.y + b.y;
	return (result);
}

t_vector2	vec2_subtract(t_vector2 a, t_vector2 b)
{
	t_vector2	result;

	result.x = a.x - b.x;
	result.y = a.y - b.y;
	return (result);
}

t_vector2	vec2_multiply(t_vector2 vec, float scalar)
{
	t_vector2	result;

	result.x = vec.x * scalar;
	result.y = vec.y * scalar;
	return (result);
}

t_vector2	vec2_divide(t_vector2 vec, float scalar)
{
	t_vector2	result;

	if (scalar == 0.0f)
		return (vec2_zero());
	result.x = vec.x / scalar;
	result.y = vec.y / scalar;
	return (result);
}

t_vector2	vec2_zero(void)
{
	t_vector2	result;

	result.x = 0.0f;
	result.y = 0.0f;
	return (result);
}

t_vector2	vec2_one(void)
{
	t_vector2	result;

	result.x = 1.0f;
	result.y = 1.0f;
	return (result);
}

t_vector2	vec2_create(float x, float y)
{
	t_vector2	result;

	result.x = x;
	result.y = y;
	return (result);
}

bool	vec2_equals(t_vector2 a, t_vector2 b)
{
	const float	epsilon = 0.0001f;

	return (fabsf(a.x - b.x) < epsilon && fabsf(a.y - b.y) < epsilon);
}

t_color	color_create(int r, int g, int b, int a)
{
	t_color	result;

	result.r = math_clamp_int(r, 0, 255);
	result.g = math_clamp_int(g, 0, 255);
	result.b = math_clamp_int(b, 0, 255);
	result.a = math_clamp_int(a, 0, 255);
	return (result);
}

t_color	color_white(void)
{
	return (color_create(255, 255, 255, 255));
}

t_color	color_black(void)
{
	return (color_create(0, 0, 0, 255));
}

t_color	color_red(void)
{
	return (color_create(255, 0, 0, 255));
}

t_color	color_green(void)
{
	return (color_create(0, 255, 0, 255));
}

t_color	color_blue(void)
{
	return (color_create(0, 0, 255, 255));
}

t_color	color_yellow(void)
{
	return (color_create(255, 255, 0, 255));
}

t_color	color_gray(void)
{
	return (color_create(128, 128, 128, 255));
}

t_color	color_lerp(t_color a, t_color b, float t)
{
	t_color	result;

	result.r = (int)math_lerp((float)a.r, (float)b.r, t);
	result.g = (int)math_lerp((float)a.g, (float)b.g, t);
	result.b = (int)math_lerp((float)a.b, (float)b.b, t);
	result.a = (int)math_lerp((float)a.a, (float)b.a, t);
	return (result);
}

SDL_Color	color_to_sdl(t_color color)
{
	SDL_Color	result;

	result.r = (Uint8)color.r;
	result.g = (Uint8)color.g;
	result.b = (Uint8)color.b;
	result.a = (Uint8)color.a;
	return (result);
}

t_vector2	world_to_grid(t_vector2 world_pos)
{
	t_vector2	result;

	result.x = (float)world_to_grid_x(world_pos.x);
	result.y = (float)world_to_grid_y(world_pos.y);
	return (result);
}

t_vector2	grid_to_world(int grid_x, int grid_y)
{
	t_vector2	result;

	result.x = grid_to_world_x(grid_x);
	result.y = grid_to_world_y(grid_y);
	return (result);
}

bool	is_valid_grid_pos(int x, int y)
{
	return (x >= 0 && x < GRID_COLS && y >= 0 && y < GRID_ROWS);
}

int	world_to_grid_x(float world_x)
{
	return ((int)(world_x / GRID_SIZE));
}

int	world_to_grid_y(float world_y)
{
	return ((int)(world_y / GRID_SIZE));
}

float	grid_to_world_x(int grid_x)
{
	return ((float)grid_x * GRID_SIZE + GRID_SIZE * 0.5f);
}

float	grid_to_world_y(int grid_y)
{
	return ((float)grid_y * GRID_SIZE + GRID_SIZE * 0.5f);
}


================================================
File: srcs/utils/memory.c
================================================
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   memory.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ellucas <ellucas@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/25 16:00:00 by jynra             #+#    #+#             */
/*   Updated: 2025/05/25 13:02:39 by ellucas          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "utils.h"

static size_t	g_total_allocated = 0;
static size_t	g_allocation_count = 0;

void	*memory_alloc(size_t size)
{
	void	*ptr;

	if (size == 0)
	{
		debug_warning("Attempting to allocate 0 bytes");
		return (NULL);
	}
	ptr = malloc(size);
	if (!ptr)
	{
		debug_error("Failed to allocate %zu bytes", size);
		return (NULL);
	}
	g_total_allocated += size;
	g_allocation_count++;
	debug_log("Allocated %zu bytes at %p", size, ptr);
	return (ptr);
}

void	memory_free(void *ptr)
{
	if (!ptr)
	{
		debug_warning("Attempting to free NULL pointer");
		return ;
	}
	free(ptr);
	g_allocation_count--;
	debug_log("Freed memory at %p", ptr);
}

void	*memory_realloc(void *ptr, size_t size)
{
	void	*new_ptr;

	if (size == 0)
	{
		memory_free(ptr);
		return (NULL);
	}
	if (!ptr)
		return (memory_alloc(size));
	new_ptr = realloc(ptr, size);
	if (!new_ptr)
	{
		debug_error("Failed to reallocate %zu bytes", size);
		return (NULL);
	}
	debug_log("Reallocated %zu bytes from %p to %p", size, ptr, new_ptr);
	return (new_ptr);
}

void	memory_set(void *ptr, int value, size_t size)
{
	if (!validate_pointer(ptr))
		return ;
	memset(ptr, value, size);
}

void	memory_copy(void *dest, const void *src, size_t size)
{
	if (!validate_pointer(dest) || !validate_pointer(src))
		return ;
	memcpy(dest, src, size);
}

int	memory_compare(const void *a, const void *b, size_t size)
{
	if (!validate_pointer(a) || !validate_pointer(b))
		return (0);
	return (memcmp(a, b, size));
}

int	string_length(const char *str)
{
	int	len;

	if (!str)
		return (0);
	len = 0;
	while (str[len])
		len++;
	return (len);
}

char	*string_copy(char *dest, const char *src)
{
	int	i;

	if (!dest || !src)
		return (NULL);
	i = 0;
	while (src[i])
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = '\0';
	return (dest);
}

char	*string_concat(char *dest, const char *src)
{
	int	dest_len;
	int	i;

	if (!dest || !src)
		return (NULL);
	dest_len = string_length(dest);
	i = 0;
	while (src[i])
	{
		dest[dest_len + i] = src[i];
		i++;
	}
	dest[dest_len + i] = '\0';
	return (dest);
}

int	string_compare(const char *a, const char *b)
{
	int	i;

	if (!a || !b)
		return (0);
	i = 0;
	while (a[i] && b[i] && a[i] == b[i])
		i++;
	return (a[i] - b[i]);
}

char	*string_find(const char *haystack, const char *needle)
{
	int	i;
	int	j;

	if (!haystack || !needle)
		return (NULL);
	if (!needle[0])
		return ((char *)haystack);
	i = 0;
	while (haystack[i])
	{
		j = 0;
		while (haystack[i + j] && needle[j] 
			&& haystack[i + j] == needle[j])
			j++;
		if (!needle[j])
			return ((char *)&haystack[i]);
		i++;
	}
	return (NULL);
}

void	string_to_lower(char *str)
{
	int	i;

	if (!str)
		return ;
	i = 0;
	while (str[i])
	{
		if (str[i] >= 'A' && str[i] <= 'Z')
			str[i] += 32;
		i++;
	}
}

void	string_to_upper(char *str)
{
	int	i;

	if (!str)
		return ;
	i = 0;
	while (str[i])
	{
		if (str[i] >= 'a' && str[i] <= 'z')
			str[i] -= 32;
		i++;
	}
}

bool	string_starts_with(const char *str, const char *prefix)
{
	int	i;

	if (!str || !prefix)
		return (false);
	i = 0;
	while (prefix[i])
	{
		if (str[i] != prefix[i])
			return (false);
		i++;
	}
	return (true);
}

bool	string_ends_with(const char *str, const char *suffix)
{
	int	str_len;
	int	suffix_len;
	int	i;

	if (!str || !suffix)
		return (false);
	str_len = string_length(str);
	suffix_len = string_length(suffix);
	if (suffix_len > str_len)
		return (false);
	i = 0;
	while (i < suffix_len)
	{
		if (str[str_len - suffix_len + i] != suffix[i])
			return (false);
		i++;
	}
	return (true);
}

